//@ts-check
/* eslint-env es2022 */
import { args, ignoreError, logThenExit1, shell$ } from '@maranomynet/libtools';
import esbuild from 'esbuild';
import { mkdir, readFile, writeFile } from 'fs/promises';
import { sync as globSync } from 'glob';
import { dirname } from 'path';

export { esbuild };

export const isDev = !!args.dev;

export const testsDir = '__tests';
export const distDir = '_npm-lib';
export const srcDir = 'src';

export const testGlobs = `${srcDir}/**/*.tests.{ts,tsx}`;

// ---------------------------------------------------------------------------

/**
 * @param {string} [path] - The package.json path to read.
 * @returns {Promise<{
 *   name: string,
 *   version: string,
 *   [key: string]: unknown
 * }>}
 */
const readPackageJson = (path) =>
  readFile(path || './package.json').then((buffer) => JSON.parse(buffer.toString()));

/**
 * @param {string} outDir
 * @param {Record<string, unknown>} [extraFields]
 * @returns {Promise<void>}
 */
const makePackageJson = async (outDir, extraFields) => {
  const pkg = await readPackageJson();
  const newPkg = { ...pkg };
  const { publishConfig } = newPkg;
  delete newPkg.publishConfig;

  delete newPkg.scripts;
  delete newPkg.hxmstyle;
  delete newPkg.private;
  delete newPkg.devDependencies;
  Object.assign(newPkg, publishConfig, extraFields);

  await writeFile(`${outDir}/package.json`, JSON.stringify(newPkg, null, '\t'));
};

// ---------------------------------------------------------------------------

/**
 * @param {boolean} stripHashPrefix
 * @returns {(
 *   res: esbuild.BuildResult | null,
 *   err?: unknown,
 *   onChange?: ((fileName: string) => void)
 * ) => void}
 */
const makeWriteOnlyAffected = (stripHashPrefix) => {
  let fileMem = {};
  return (res, err, onChange) => {
    if (!res || err) {
      return;
    }
    const { outputFiles = [] } = res;
    const newFiles = {};
    const cwdLength = process.cwd().length + 1;
    outputFiles
      .filter(({ path }) => !fileMem[path])
      .forEach(({ path, text }) => {
        const targetDir = dirname(path);
        newFiles[path] = 1;
        if (stripHashPrefix) {
          path = path.replace(/(^|\/)\$\$[A-Z0-9]+\$\$-/, '$1');
        }
        mkdir(targetDir, { recursive: true })
          .then(() => writeFile(path, text))
          .then(() => onChange?.(path.slice(cwdLength)));
      });
    // map this set of outputFiles as the fileMem for next time
    fileMem = {};
    outputFiles.forEach(({ path }) => {
      fileMem[path] = 1;
    });
  };
};

// ---------------------------------------------------------------------------

/**
 * Run tsc typecheck on the current project module
 *
 * @returns {Promise<void>}
 */
export const typeCheckModule = () =>
  shell$(
    `yarn run -T tsc --project ./tsconfig.json --noEmit --pretty --incremental false`
  );

// ---------------------------------------------------------------------------

/**
 * @param {{
 *   compilerOptions?: Record<string, unknown>;
 *   include: string[];
 *   exlude?: string[]
 * }}  [config]
 * @returns {Promise<void>}
 */
const tscBuild = async (config) => {
  const cfgFile = `tsconfig.build.TEMP.json`;
  await writeFile(
    cfgFile,
    `// This file is auto-generated by build.mjs\n${JSON.stringify(
      { extends: './tsconfig.json', ...config },
      null,
      '\t'
    )}`
  );
  try {
    await shell$(`yarn run -T tsc --project ${cfgFile}  &&  rm ${cfgFile}`);
  } catch (err) {
    await shell$(`rm ${cfgFile}`);
    logThenExit1(new Error(err.output.toString()));
  }
};

// ---------------------------------------------------------------------------

export const getExternalDeps = () =>
  Promise.all([readPackageJson(), readPackageJson('../../package.json')]).then(
    ([pkg, rootPkg]) =>
      [
        ...Object.keys(pkg.dependencies || {}),
        ...Object.keys(pkg.devDependencies || {}),
        ...Object.keys(rootPkg.dependencies || {}),
        ...Object.keys(rootPkg.devDependencies || {}),
      ].filter((name) => !name.startsWith('@reykjavik/hanna-'))
  );

/**
 * @param {Array<string>} entryPoints
 * @param {string} outdir
 * @param {{
 *   watch?: boolean,
 *   typeCheck?: boolean,
 *   emptyOutdir?: boolean,
 *   entryNames?: string,
 *   onChange?: (fileName: string) => void
 * }} [options]
 * @returns {Promise<void>}
 */
export const esbuildBuild = async (entryPoints, outdir, options) => {
  const { watch, typeCheck, entryNames, onChange } = options || {};

  if (typeCheck) {
    await typeCheckModule();
  }

  const writeOnlyAffected = makeWriteOnlyAffected(true);
  const external = await getExternalDeps();

  return esbuild
    .build({
      bundle: true,
      external,
      format: 'cjs',
      platform: 'node',
      target: ['node16'],
      entryPoints,
      entryNames,
      write: false,
      watch: watch && {
        onRebuild: (err, results) => writeOnlyAffected(results, err, onChange),
      },
      outdir,
    })
    .then((res) => {
      writeOnlyAffected(res);
      if (isDev) {
        process.on('exit', () => res.stop?.());
      }
    })
    .catch(logThenExit1);
};

// ---------------------------------------------------------------------------

/**
 * @returns {Promise<void>}
 */
export const buildAndRunTests = async () => {
  await shell$(`rm -rf ${testsDir} && mkdir -p ${testsDir}`);
  await esbuildBuild(globSync(testGlobs), testsDir, {
    watch: isDev,
    typeCheck: !isDev,
    entryNames: '[dir]/$$[hash]$$-[name]',
    onChange: (fileName) => shell$(`yarn run -T ospec ${fileName}`).catch(ignoreError),
  });
  await shell$(`yarn run -T ospec "${testsDir}/**/*.tests.js"`).catch(ignoreError);
};

// ---------------------------------------------------------------------------

/**
 * @param {Array<string>} entryPoints
 * @param {string} distFolder
 */
const addReferenePathsToIndex = async (entryPoints, distFolder) => {
  const dtsify = (tsFilePath) => tsFilePath.replace(/\.(tsx?)$/, '.d.$1');
  const indexTsFile = entryPoints.find((filePath) =>
    /(?:^|\/)index.tsx?$/.test(filePath)
  );

  if (indexTsFile) {
    const extraEntryPaths = entryPoints
      .filter((filePath) => filePath !== indexTsFile)
      .map(dtsify)
      .map((declFile) => `/// <reference path="./${declFile}" />`);
    if (extraEntryPaths.length > 0) {
      const indexDeclFile = `${distFolder}/${dtsify(indexTsFile)}`;
      await writeFile(
        indexDeclFile,
        `${extraEntryPaths.join('\n')}\n\n${await readFile(indexDeclFile)}`
      );
    }
  }
};

// ---------------------------------------------------------------------------

/**
 * @param {string} libName - The name of the library.
 * @param {{
 *   src?: string,
 *   cpCmds?: Array<string>,
 *   entryGlobs?: Array<string>,
 *   sideEffects?: Array<string>,
 *   shallowCopy?: boolean
 * }} [custom] - Custom build options.
 * @returns {Promise<void>}
 */
export const buildNpmLib = async (libName, custom) => {
  if (isDev) {
    await shell$(`rm -rf ${distDir}`);
    return;
  }

  const {
    src = srcDir,
    cpCmds = [`cp README.md  CHANGELOG.md ${distDir}`],
    entryGlobs = [`*.{ts,tsx}`],
    sideEffects,
    shallowCopy = false,
  } = custom || {};

  const entryPoints = entryGlobs.flatMap((entryGlob) =>
    globSync(entryGlob, {
      cwd: src,
      ignore: ['**/*.{tests,privates}.{ts,tsx}', '**/_*'],
    })
  );

  if (!libName) {
    throw new Error('`libName` argument is required');
  }
  await shell$([`rm -rf ${distDir}`, `mkdir ${distDir} ${distDir}/esm`, ...cpCmds]);
  await writeFile(`${distDir}/esm/package.json`, JSON.stringify({ type: 'module' }));

  await makePackageJson(distDir, {
    sideEffects,
    exports: Object.fromEntries(
      entryPoints.map((file) => {
        const token = file.replace(/\.tsx?$/, '');
        const expToken = `./${token}`.replace(/\/index$/, '');
        return [
          expToken,
          {
            import: `./esm/${token}.js`,
            require: `./${token}.js`,
          },
        ];
      })
    ),
  });

  /* eslint-disable no-await-in-loop */
  for (const module of ['commonjs', 'esnext']) {
    const tempOutDir = `${distDir}/temp`;
    const tempLibRoot = shallowCopy
      ? tempOutDir
      : `${tempOutDir}/hanna-${libName}/${src}`;

    await tscBuild({
      compilerOptions: {
        module,
        declaration: true,
        outDir: tempOutDir,
      },
      include: entryPoints.map((file) => `${src}/${file}`),
    });
    await addReferenePathsToIndex(entryPoints, tempLibRoot);

    const rootDir = module === 'esnext' ? 'esm' : '.';
    await shell$([
      `mv ${tempLibRoot}/* ${distDir}/${rootDir}`,
      `rm -rf ${tempOutDir}`,
      // â€¦
    ]);
  }
  /* eslint-enable no-await-in-loop */
};

// ---------------------------------------------------------------------------

/**
 * @param {string} packageName
 * @param {string} newVersion
 * @param {Array<string>} [updatePkgs]
 * @returns {Promise<Array<string>>} - package.json files that were updated.
 */
export const updateDependentPackages = async (
  packageName,
  newVersion,
  updatePkgs = []
) => {
  const updatedPkgs = [];

  /* eslint-disable no-await-in-loop */
  for (const updatedPkgName of updatePkgs) {
    const updatedPkgFile = `../${updatedPkgName}/package.json`;
    const originalPkgStr = (await readFile(updatedPkgFile)).toString();
    const updatedPkgStr = originalPkgStr.replace(
      new RegExp(`("${packageName}": "\\^)(?:\\d+\\.\\d+\\.\\d+)(")`, 'g'),
      `$1${newVersion}$2`
    );
    if (updatedPkgStr === originalPkgStr) {
      throw new Error(
        `Could not find "${packageName}" as a versioned dependency in ${updatedPkgFile}`
      );
    }
    await writeFile(updatedPkgFile, updatedPkgStr);
    updatedPkgs.push(updatedPkgFile);
  }
  /* eslint-enable no-await-in-loop */
  return updatedPkgs;
};

// ---------------------------------------------------------------------------

/**
 * @typedef {{
 *   changelogSuffix?: string,
 *   updatePkgs?: Array<string>
 *   tag?: string
 * }}  PublishOpts
 */

/**
 * @param {PublishOpts} [opts]
 * @returns {Promise<void>}
 */
export const publishToNpm = async (opts = {}) => {
  const { changelogSuffix = '', updatePkgs } = opts;

  const pkg = await readPackageJson();
  const version = pkg.version;

  const tag = opts.tag || version.split('-')[1]?.split('.')[0];
  const tagArg = tag ? `--tag ${tag}` : '';

  let updatedPkgFiles = [];
  if (!tag) {
    updatedPkgFiles = await updateDependentPackages(pkg.name, version, updatePkgs).catch(
      logThenExit1
    );
  }

  const shortPkgName = pkg.name.replace(/^@reykjavik\//, '');

  await shell$([
    `cd _npm-lib`,
    `npm publish --access public ${tagArg}`,
    `cd ..`,
    updatedPkgFiles.length && `yarn install`,
    updatedPkgFiles.length && `git add ../../yarn.lock ${updatedPkgFiles.join(' ')}`,
    `git add ./package.json ./CHANGELOG${changelogSuffix}.md`,
    `git commit -m "release(${shortPkgName}): v${version}"`,
  ]);
};
